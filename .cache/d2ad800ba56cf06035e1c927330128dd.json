{"dependencies":[{"name":"../clip/antimeridian.js","loc":{"line":1,"column":29}},{"name":"../clip/circle.js","loc":{"line":2,"column":23}},{"name":"../clip/rectangle.js","loc":{"line":3,"column":26}},{"name":"../compose.js","loc":{"line":4,"column":20}},{"name":"../identity.js","loc":{"line":5,"column":21}},{"name":"../math.js","loc":{"line":6,"column":47}},{"name":"../rotation.js","loc":{"line":7,"column":28}},{"name":"../transform.js","loc":{"line":8,"column":26}},{"name":"./fit.js","loc":{"line":9,"column":54}},{"name":"./resample.js","loc":{"line":10,"column":21}}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = projection;\nexports.projectionMutator = projectionMutator;\n\nvar _antimeridian = require(\"../clip/antimeridian.js\");\n\nvar _antimeridian2 = _interopRequireDefault(_antimeridian);\n\nvar _circle = require(\"../clip/circle.js\");\n\nvar _circle2 = _interopRequireDefault(_circle);\n\nvar _rectangle = require(\"../clip/rectangle.js\");\n\nvar _rectangle2 = _interopRequireDefault(_rectangle);\n\nvar _compose = require(\"../compose.js\");\n\nvar _compose2 = _interopRequireDefault(_compose);\n\nvar _identity = require(\"../identity.js\");\n\nvar _identity2 = _interopRequireDefault(_identity);\n\nvar _math = require(\"../math.js\");\n\nvar _rotation = require(\"../rotation.js\");\n\nvar _transform = require(\"../transform.js\");\n\nvar _fit = require(\"./fit.js\");\n\nvar _resample = require(\"./resample.js\");\n\nvar _resample2 = _interopRequireDefault(_resample);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar transformRadians = (0, _transform.transformer)({\n  point: function (x, y) {\n    this.stream.point(x * _math.radians, y * _math.radians);\n  }\n});\n\nfunction transformRotate(rotate) {\n  return (0, _transform.transformer)({\n    point: function (x, y) {\n      var r = rotate(x, y);\n      return this.stream.point(r[0], r[1]);\n    }\n  });\n}\n\nfunction scaleTranslate(k, dx, dy, sx, sy) {\n  function transform(x, y) {\n    x *= sx;y *= sy;\n    return [dx + k * x, dy - k * y];\n  }\n  transform.invert = function (x, y) {\n    return [(x - dx) / k * sx, (dy - y) / k * sy];\n  };\n  return transform;\n}\n\nfunction scaleTranslateRotate(k, dx, dy, sx, sy, alpha) {\n  if (!alpha) return scaleTranslate(k, dx, dy, sx, sy);\n  var cosAlpha = (0, _math.cos)(alpha),\n      sinAlpha = (0, _math.sin)(alpha),\n      a = cosAlpha * k,\n      b = sinAlpha * k,\n      ai = cosAlpha / k,\n      bi = sinAlpha / k,\n      ci = (sinAlpha * dy - cosAlpha * dx) / k,\n      fi = (sinAlpha * dx + cosAlpha * dy) / k;\n  function transform(x, y) {\n    x *= sx;y *= sy;\n    return [a * x - b * y + dx, dy - b * x - a * y];\n  }\n  transform.invert = function (x, y) {\n    return [sx * (ai * x - bi * y + ci), sy * (fi - bi * x - ai * y)];\n  };\n  return transform;\n}\n\nfunction projection(project) {\n  return projectionMutator(function () {\n    return project;\n  })();\n}\n\nfunction projectionMutator(projectAt) {\n  var project,\n      k = 150,\n      // scale\n  x = 480,\n      y = 250,\n      // translate\n  lambda = 0,\n      phi = 0,\n      // center\n  deltaLambda = 0,\n      deltaPhi = 0,\n      deltaGamma = 0,\n      rotate,\n      // pre-rotate\n  alpha = 0,\n      // post-rotate angle\n  sx = 1,\n      // reflectX\n  sy = 1,\n      // reflectX\n  theta = null,\n      preclip = _antimeridian2.default,\n      // pre-clip angle\n  x0 = null,\n      y0,\n      x1,\n      y1,\n      postclip = _identity2.default,\n      // post-clip extent\n  delta2 = 0.5,\n      // precision\n  projectResample,\n      projectTransform,\n      projectRotateTransform,\n      cache,\n      cacheStream;\n\n  function projection(point) {\n    return projectRotateTransform(point[0] * _math.radians, point[1] * _math.radians);\n  }\n\n  function invert(point) {\n    point = projectRotateTransform.invert(point[0], point[1]);\n    return point && [point[0] * _math.degrees, point[1] * _math.degrees];\n  }\n\n  projection.stream = function (stream) {\n    return cache && cacheStream === stream ? cache : cache = transformRadians(transformRotate(rotate)(preclip(projectResample(postclip(cacheStream = stream)))));\n  };\n\n  projection.preclip = function (_) {\n    return arguments.length ? (preclip = _, theta = undefined, reset()) : preclip;\n  };\n\n  projection.postclip = function (_) {\n    return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;\n  };\n\n  projection.clipAngle = function (_) {\n    return arguments.length ? (preclip = +_ ? (0, _circle2.default)(theta = _ * _math.radians) : (theta = null, _antimeridian2.default), reset()) : theta * _math.degrees;\n  };\n\n  projection.clipExtent = function (_) {\n    return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, _identity2.default) : (0, _rectangle2.default)(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];\n  };\n\n  projection.scale = function (_) {\n    return arguments.length ? (k = +_, recenter()) : k;\n  };\n\n  projection.translate = function (_) {\n    return arguments.length ? (x = +_[0], y = +_[1], recenter()) : [x, y];\n  };\n\n  projection.center = function (_) {\n    return arguments.length ? (lambda = _[0] % 360 * _math.radians, phi = _[1] % 360 * _math.radians, recenter()) : [lambda * _math.degrees, phi * _math.degrees];\n  };\n\n  projection.rotate = function (_) {\n    return arguments.length ? (deltaLambda = _[0] % 360 * _math.radians, deltaPhi = _[1] % 360 * _math.radians, deltaGamma = _.length > 2 ? _[2] % 360 * _math.radians : 0, recenter()) : [deltaLambda * _math.degrees, deltaPhi * _math.degrees, deltaGamma * _math.degrees];\n  };\n\n  projection.angle = function (_) {\n    return arguments.length ? (alpha = _ % 360 * _math.radians, recenter()) : alpha * _math.degrees;\n  };\n\n  projection.reflectX = function (_) {\n    return arguments.length ? (sx = _ ? -1 : 1, recenter()) : sx < 0;\n  };\n\n  projection.reflectY = function (_) {\n    return arguments.length ? (sy = _ ? -1 : 1, recenter()) : sy < 0;\n  };\n\n  projection.precision = function (_) {\n    return arguments.length ? (projectResample = (0, _resample2.default)(projectTransform, delta2 = _ * _), reset()) : (0, _math.sqrt)(delta2);\n  };\n\n  projection.fitExtent = function (extent, object) {\n    return (0, _fit.fitExtent)(projection, extent, object);\n  };\n\n  projection.fitSize = function (size, object) {\n    return (0, _fit.fitSize)(projection, size, object);\n  };\n\n  projection.fitWidth = function (width, object) {\n    return (0, _fit.fitWidth)(projection, width, object);\n  };\n\n  projection.fitHeight = function (height, object) {\n    return (0, _fit.fitHeight)(projection, height, object);\n  };\n\n  function recenter() {\n    var center = scaleTranslateRotate(k, 0, 0, sx, sy, alpha).apply(null, project(lambda, phi)),\n        transform = scaleTranslateRotate(k, x - center[0], y - center[1], sx, sy, alpha);\n    rotate = (0, _rotation.rotateRadians)(deltaLambda, deltaPhi, deltaGamma);\n    projectTransform = (0, _compose2.default)(project, transform);\n    projectRotateTransform = (0, _compose2.default)(rotate, projectTransform);\n    projectResample = (0, _resample2.default)(projectTransform, delta2);\n    return reset();\n  }\n\n  function reset() {\n    cache = cacheStream = null;\n    return projection;\n  }\n\n  return function () {\n    project = projectAt.apply(this, arguments);\n    projection.invert = project.invert && invert;\n    return recenter();\n  };\n}"},"hash":"b936acdf36f21874df4b45a0bff3ae19"}