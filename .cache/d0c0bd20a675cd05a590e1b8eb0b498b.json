{"dependencies":[{"name":"./math.js","loc":{"line":1,"column":23}}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = function () {\n  return chord(false, false);\n};\n\nexports.chordTranspose = chordTranspose;\nexports.chordDirected = chordDirected;\n\nvar _math = require(\"./math.js\");\n\nfunction range(i, j) {\n  return Array.from({ length: j - i }, (_, k) => i + k);\n}\n\nfunction compareValue(compare) {\n  return function (a, b) {\n    return compare(a.source.value + a.target.value, b.source.value + b.target.value);\n  };\n}\n\nfunction chordTranspose() {\n  return chord(false, true);\n}\n\nfunction chordDirected() {\n  return chord(true, false);\n}\n\nfunction chord(directed, transpose) {\n  var padAngle = 0,\n      sortGroups = null,\n      sortSubgroups = null,\n      sortChords = null;\n\n  function chord(matrix) {\n    var n = matrix.length,\n        groupSums = new Array(n),\n        groupIndex = range(0, n),\n        chords = new Array(n * n),\n        groups = new Array(n),\n        k = 0,\n        dx;\n\n    matrix = Float64Array.from({ length: n * n }, transpose ? (_, i) => matrix[i % n][i / n | 0] : (_, i) => matrix[i / n | 0][i % n]);\n\n    // Compute the scaling factor from value to angle in [0, 2pi].\n    for (let i = 0; i < n; ++i) {\n      let x = 0;\n      for (let j = 0; j < n; ++j) x += matrix[i * n + j] + directed * matrix[j * n + i];\n      k += groupSums[i] = x;\n    }\n    k = (0, _math.max)(0, _math.tau - padAngle * n) / k;\n    dx = k ? padAngle : _math.tau / n;\n\n    // Compute the angles for each group and constituent chord.\n    {\n      let x = 0;\n      if (sortGroups) groupIndex.sort((a, b) => sortGroups(groupSums[a], groupSums[b]));\n      for (const i of groupIndex) {\n        const x0 = x;\n        if (directed) {\n          const subgroupIndex = range(~n + 1, n).filter(j => j < 0 ? matrix[~j * n + i] : matrix[i * n + j]);\n          if (sortSubgroups) subgroupIndex.sort((a, b) => sortSubgroups(a < 0 ? -matrix[~a * n + i] : matrix[i * n + a], b < 0 ? -matrix[~b * n + i] : matrix[i * n + b]));\n          for (const j of subgroupIndex) {\n            if (j < 0) {\n              const chord = chords[~j * n + i] || (chords[~j * n + i] = { source: null, target: null });\n              chord.target = { index: i, startAngle: x, endAngle: x += matrix[~j * n + i] * k, value: matrix[~j * n + i] };\n            } else {\n              const chord = chords[i * n + j] || (chords[i * n + j] = { source: null, target: null });\n              chord.source = { index: i, startAngle: x, endAngle: x += matrix[i * n + j] * k, value: matrix[i * n + j] };\n            }\n          }\n          groups[i] = { index: i, startAngle: x0, endAngle: x, value: groupSums[i] };\n        } else {\n          const subgroupIndex = range(0, n).filter(j => matrix[i * n + j] || matrix[j * n + i]);\n          if (sortSubgroups) subgroupIndex.sort((a, b) => sortSubgroups(matrix[i * n + a], matrix[i * n + b]));\n          for (const j of subgroupIndex) {\n            let chord;\n            if (i < j) {\n              chord = chords[i * n + j] || (chords[i * n + j] = { source: null, target: null });\n              chord.source = { index: i, startAngle: x, endAngle: x += matrix[i * n + j] * k, value: matrix[i * n + j] };\n            } else {\n              chord = chords[j * n + i] || (chords[j * n + i] = { source: null, target: null });\n              chord.target = { index: i, startAngle: x, endAngle: x += matrix[i * n + j] * k, value: matrix[i * n + j] };\n              if (i === j) chord.source = chord.target;\n            }\n            if (chord.source && chord.target && chord.source.value < chord.target.value) {\n              const source = chord.source;\n              chord.source = chord.target;\n              chord.target = source;\n            }\n          }\n          groups[i] = { index: i, startAngle: x0, endAngle: x, value: groupSums[i] };\n        }\n        x += dx;\n      }\n    }\n\n    // Remove empty chords.\n    chords = Object.values(chords);\n    chords.groups = groups;\n    return sortChords ? chords.sort(sortChords) : chords;\n  }\n\n  chord.padAngle = function (_) {\n    return arguments.length ? (padAngle = (0, _math.max)(0, _), chord) : padAngle;\n  };\n\n  chord.sortGroups = function (_) {\n    return arguments.length ? (sortGroups = _, chord) : sortGroups;\n  };\n\n  chord.sortSubgroups = function (_) {\n    return arguments.length ? (sortSubgroups = _, chord) : sortSubgroups;\n  };\n\n  chord.sortChords = function (_) {\n    return arguments.length ? (_ == null ? sortChords = null : (sortChords = compareValue(_))._ = _, chord) : sortChords && sortChords._;\n  };\n\n  return chord;\n}"},"hash":"acf51390a3e6f3eae7e7902f7aa84adb"}